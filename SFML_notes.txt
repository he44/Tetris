/*	About:
	This file contains the notes I took while reading through SFML
	documentation and tutorials
*/

/*============================================================================*/
/*								Notes on Events								  */
/*============================================================================*/
/*
1. 	sf::Event is a union --> only one of its members can be true at a time
2.	sf::Event are filled by pollEvent/waitEvent
3.	Following is the common way taking care of events
*/

// sf::Event event;
// // while there are pending events...
// while (window.pollEvent(event))
// {
//     // check the type of the event...
//     switch (event.type)
//     {
//         // window closed
//         case sf::Event::Closed:
//             window.close();
//             break;

//         // key pressed
//         case sf::Event::KeyPressed:
//             ...
//             break;

//         // we don't process other types of events
//         default:
//             break;
//     }
// }

/*===============*/
/*	Event Types  */
/*===============*/
/*
=================	window	=================
1.	Closed event 
	triggered when user tries to close the window
	The window is not closed yet at this point. 
	Can choose to save window status, ask for further information from the user,
	or call window.close() directly
2.	Resized event
	triggered when window is resized (user/code)
	window.setSize()
	event.size.width
	event.size.height
3.	LostFocus/GainedFocus event
	triggered when the window loses/gains focus
	user switches active window --> out of focus --> won't receive key strokes
	Can choose to pause when focus is lost

=================	Keyboard	=================
4.	TextEntered event
	triggered when a character is typed
	produces the appropriate character (Shift + a gives A)
	if (event.text.unicode< 128){	
		char = (char)event.text.unicode;
	}
	Non-printable chars(backspace) generated by this event
5.	KeyPressed/KeyReleased event
	triggered when a keyboard key is pressed/released
	key held --> repeated KeyPressed events
	can be disabled: window.setKeyRepeatEnabled(false)
	keyReleased can never be repeated
	to get smooth reacton: get a flag set after pressed, and cleared after 
	released
	event.key
	if (event.type == sf::Event::KeyPressed){
	    if (event.key.code == sf::Keyboard::Escape){
	        std::cout << "the escape key was pressed" << std::endl;
	        std::cout << "control:" << event.key.control << std::endl;
	        std::cout << "alt:" << event.key.alt << std::endl;
	        std::cout << "shift:" << event.key.shift << std::endl;
	        std::cout << "system:" << event.key.system << std::endl;
	    }
	}	
6.	MouseWheelMoved event
	triggered when a mouse wheel moves up/down
	if (event.type == sf::Event::MouseWheelScrolled){
	    if (event.mouseWheelScroll.wheel == sf::Mouse::VerticalWheel)
	        std::cout << "wheel type: vertical" << std::endl;
	    else if (event.mouseWheelScroll.wheel == sf::Mouse::HorizontalWheel)
	        std::cout << "wheel type: horizontal" << std::endl;
	    else
	        std::cout << "wheel type: unknown" << std::endl;
	    std::cout << "wheel movement: " << event.mouseWheelScroll.delta << std::endl;
	    std::cout << "mouse x: " << event.mouseWheelScroll.x << std::endl;
	    std::cout << "mouse y: " << event.mouseWheelScroll.y << std::endl;
	}
7.	MouseButtonPressed/MouseButtonReleased event
	triggered when a mouse button is pressed/released
	Right/Left/Middle/Extra 1/Extra 2
	if (event.type == sf::Event::MouseButtonPressed){
	    if (event.mouseButton.button == sf::Mouse::Right){
	        std::cout << "the right button was pressed" << std::endl;
	        std::cout << "mouse x: " << event.mouseButton.x << std::endl;
	        std::cout << "mouse y: " << event.mouseButton.y << std::endl;
	    }
	}
8.	MouseMoved event
	triggered when the mouse moved in the window
	event.mouseMove.x -- current mouse position x
	event.mouseMove.y -- current mouse position y
9.	MouseEntered MouseLeft event
	triggered when mouse cursoe enters/leaves the window

=================	Joy Stick	=================	

*/
/*======================*/
/*	Keyboard Devices	*/
/*======================*/
/*	
=================	Notice	=================
Real-time input allows you to query the global state of keyboard, mouse and 
joysticks at any time

events notify you when something happens

=================	Keyboard	=================
if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left)){
    // left key is pressed: move our character
    character.move(1, 0);
}

Key codes are defined in the sf::Keyboard::Key enum.
This returns true even if window is not active

=================	Mouse	=================
if (sf::Mouse::isButtonPressed(sf::Mouse::Left)){
    // left mouse button is pressed: shoot
    gun.fire();
}

Mouse button codes are defined in the sf::Mouse::Button enum
*/


/*===============*/
/*	2D Drawing   */
/*===============*/
/*	
1.	Basic:
	SFML provides a graphics module which will help you draw 2D entities in a much simpler way than with OpenGL;

	Use a specialized window class: sf::RenderWindow, derived from sf::Window, and inherits all its functions
	--> creation/managing/events work the same way as window

	Three main functions:
	clear(): clears the whole window with the chosen color 
	draw(): draws whatever object you pass to it
	display(): takes what was drawn since the last call to display and displays it on the window

	Calling clear before drawing anything is MANDATORY, otherwise the contents from previous frames will be present behind anything you draw

	draw() only draws to a hidden buffer, display() copies that buffer to window
	"Double Buffering":	-- Does this sound familiar? Yes!
	ECE391 MP2 and MP3

	clear-draw-display: good way to draw things

2.	Off-screen drawing
	draw to a texture instead of directly to a window

	Example code:

		// create a 500x500 render-texture
		sf::RenderTexture renderTexture;
		if (!renderTexture.create(500, 500))
		{
		    // error...
		}

		// drawing uses the same functions
		renderTexture.clear();
		renderTexture.draw(sprite); // or any other drawable
		renderTexture.display();

		// get the target texture (where the stuff has been drawn)
		const sf::Texture& texture = renderTexture.getTexture();

		// draw it to the window
		sf::Sprite sprite(texture);
		window.draw(sprite);

3.	Drawing from threads
	-	always create the window and handle its events in the main thread
	-	deactivate a window before using it in another thread
	-	NO need to activate the window in the rendering thread, SFML does it automatically for you whenever it needs to be done
*/

/*===================*/
/*	Sprite Texture   */
/*===================*/
/*
1.	Basic:
	texture: image to be mapped to a 2-D entity
	sprite:	textured rectangle

2.	Loading:
	
	sf::Texture texture;
	if (!texture.loadFromFile("image.png")){
    	// error...
	}

	make sure image.png has a path relative to the location of executable file

	optional argument for loadFromFile:

	// load a 32x32 rectangle that starts at (10, 10)
	if (!texture.loadFromFile("image.png", sf::IntRect(10, 10, 32, 32)))
	{
	    // error...
	}

3.	Creating an empty texture and updating it

	// create an empty 200x200 texture
	if (!texture.create(200, 200))
	{
	    // error...
	}

	sf::Uint8* pixels = new sf::Uint8[width * height * 4]; // * 4 because pixels have 4 components (RGBA)

	texture.update(pixels)	
	texture.update(image)	(sf::Image image)
	texture.update(window)	(sf::RenderWindow window)

4.	Two properties of a texture
	smooth:
		texture.setSmooth(true);
	repeated:
		texture.setRepeated(true);

5.	cycle:
	sf::Texture texture;
	texture.loadFromFile("");
	sf::Sprite sprite;
	sprite.setTexture(texture);
	window.draw(sprite);

6.	Modify a sprite
	
	By default, the location of the sprite will be set at the top left corner.
	However, you can change this with: 
	sprite.setOrigin(sf::Vector2f(x, y));

	Notice: correctly manage the lifetime of your textures and make sure that they live as long as they are used by any sprite.

	Other functions:
	// position
	sprite.setPosition(sf::Vector2f(10, 50)); // absolute position
	sprite.move(sf::Vector2f(5, 10)); // offset relative to the current position

	// rotation
	sprite.setRotation(90); // absolute angle
	sprite.rotate(15); // offset relative to the current angle

	// scale
	sprite.setScale(sf::Vector2f(0.5f, 2.f)); // absolute scale factor
	sprite.scale(sf::Vector2f(1.5f, 3.f)); // factor relative to the current scale

7.	Notice:

	USE AS FEW TEXTURES AS POSSIBLE

	Changing the current texture is an expensive operation for the graphics card. Drawing many sprites that use the same texture will yield the best performance.
*/

/*===================*/
/*	Text and Fonts   */
/*===================*/
/*
1.	loading a font

	sf::Font font;
	font.loadFromFile("__.ttf");

2.	drawing text

	
	sf::Text text;

	// select the font
	text.setFont(font); // font is a sf::Font

	// set the string to display
	text.setString("Hello world");

	// set the character size
	text.setCharacterSize(24); // in pixels, not points!

	// set the color
	text.setFillColor(sf::Color::Red);

	// set the text style
	text.setStyle(sf::Text::Bold | sf::Text::Underlined);

	...

	// inside the main loop, between window.clear() and window.display()
	window.draw(text);

3.	The position and all the stuff can be set in the same way as sprite and other stuff
*/

/*===================*/
/*	Bouding Boxes    */
/*===================*/
/*
	// get the bounding box of the entity
	sf::FloatRect boundingBox = entity.getGlobalBounds();

	// check collision with a point
	sf::Vector2f point = ...;
	if (boundingBox.contains(point))
	{
	    // collision!
	}

	// check collision with another box (like the bounding box of another entity)
	sf::FloatRect otherBox = ...;
	if (boundingBox.intersects(otherBox))
	{
	    // collision!
	}
*/

/*===================*/
/*	Bouding Boxes    */
/*===================*/












